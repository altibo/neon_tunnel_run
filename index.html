<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Tunnel Run</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        #webcam-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 240px;
            height: 180px;
            transform: scaleX(-1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 10px;
            z-index: 2;
            opacity: 0.5;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 5;
            pointer-events: none;
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 25px;
            border-radius: 8px;
            border-left: 5px solid #00ffff;
            backdrop-filter: blur(5px);
            margin-bottom: 10px;
            display: inline-block;
        }
        h1 { margin: 0; font-size: 1.2rem; color: #aaa; text-transform: uppercase; letter-spacing: 2px; }
        .value { font-size: 2.5rem; font-weight: bold; font-family: monospace; text-shadow: 0 0 10px currentColor; }
        #score-val { color: #00ffff; }
        #lives-val { color: #ff0055; }
        
        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
            background: rgba(0,0,0,0.85);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #ffffff;
            display: none; /* Hidden by default */
        }
        #message-title { font-size: 3rem; margin-bottom: 10px; text-transform: uppercase; text-shadow: 0 0 20px white; }
        #message-sub { font-size: 1.2rem; margin-bottom: 20px; color: #ccc; }
        
        button {
            background: #00ffff;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            text-transform: uppercase;
            box-shadow: 0 0 15px #00ffff;
            transition: all 0.2s;
        }
        button:hover {
            transform: scale(1.1);
            background: #fff;
            box-shadow: 0 0 25px #fff;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            font-size: 2rem;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }
        
    </style>
    <!-- Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-box">
            <h1>Score</h1>
            <div id="score-val" class="value">0</div>
        </div>
        <br>
        <div class="stat-box" style="border-left-color: #ff0055;">
            <h1>Lives</h1>
            <div id="lives-val" class="value">3</div>
        </div>
    </div>

    <div id="message-overlay">
        <div id="message-title">Neon Tunnel Run</div>
        <div id="message-sub">
            Fit your hand through the holes in the neon walls.<br>
            Don't hit the walls! Speed increases over time.
        </div>
        <button onclick="startGame()">Start Game</button>
    </div>

    <div id="loading">INITIALIZING NEON SYSTEMS...</div>

    <video id="webcam-feed" playsinline></video>
    <div id="canvas-container"></div>

    <script>
        // --- Game Config ---
        const CONFIG = {
            PLAYER_Z: 0,        // Where the hand is
            SPAWN_Z: -100,      // Where walls appear
            DESPAWN_Z: 20,      // Where walls disappear
            LANE_WIDTH: 20,     // Total width of play area
            LANE_HEIGHT: 12,    // Total height of play area
            INITIAL_SPEED: 0.8,
            SPEED_INC: 0.1
        };

        let state = {
            score: 0,
            lives: 3,
            speed: CONFIG.INITIAL_SPEED,
            isPaused: true,
            isGameOver: false,
            isMenu: true, // New menu state
            frame: 0
        };

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 10); // Camera behind player
        camera.lookAt(0, 0, -20); // Look down the road

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        // --- Lights ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        // Neon glow lights
        const rectLight = new THREE.PointLight(0x00ffff, 2, 50);
        rectLight.position.set(0, 0, 5);
        scene.add(rectLight);

        // --- Environment ---
        
        // 1. The Road (Grid Floor)
        const gridHelper = new THREE.GridHelper(200, 40, 0xff00ff, 0x220033);
        gridHelper.position.set(0, -6, -40);
        gridHelper.scale.set(1, 1, 2); // Stretch Z
        scene.add(gridHelper);

        // Floor Plane (Reflection)
        const planeGeo = new THREE.PlaneGeometry(200, 300);
        const planeMat = new THREE.MeshBasicMaterial({ color: 0x050011 });
        const floor = new THREE.Mesh(planeGeo, planeMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -6.1;
        floor.position.z = -50;
        scene.add(floor);

        // 2. Stars
        const starGeo = new THREE.BufferGeometry();
        const starCount = 3000;
        const starPos = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) starPos[i] = (Math.random() - 0.5) * 200;
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.1}));
        scene.add(stars);

        // --- Hand Visuals ---
        const handGroup = new THREE.Group();
        scene.add(handGroup);
        
        // Wireframe hand
        const handMat = new THREE.LineBasicMaterial({ color: 0x00ffff });
        const handGeo = new THREE.BufferGeometry();
        const handPosBuff = new Float32Array(60 * 3); 
        handGeo.setAttribute('position', new THREE.BufferAttribute(handPosBuff, 3));
        const handWire = new THREE.LineSegments(handGeo, handMat);
        handGroup.add(handWire);

        const jointMesh = new THREE.InstancedMesh(
            new THREE.IcosahedronGeometry(0.2, 1),
            new THREE.MeshBasicMaterial({ color: 0xff00ff }),
            21
        );
        handGroup.add(jointMesh);

        // Bounding Box Visual (for player)
        const playerBoxHelper = new THREE.Box3Helper(new THREE.Box3(), 0xffff00);
        // scene.add(playerBoxHelper); // Debug
        
        let handBounds = new THREE.Box3();
        let handCenter = new THREE.Vector3();

        // --- Walls Logic ---
        const walls = [];
        const wallMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x222222, 
            emissive: 0x001133,
            shininess: 100,
            flatShading: true
        });
        const hitMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x550000, 
            emissive: 0xff0000,
            emissiveIntensity: 2
        });

        class Wall {
            constructor(zPos) {
                this.group = new THREE.Group();
                this.group.position.z = zPos;
                this.passed = false;
                this.hit = false;
                
                // Select Type
                const types = ['circle', 'rect'];
                this.type = types[Math.floor(Math.random() * types.length)];
                
                // Config
                // Ensure hole stays roughly within view
                const safeX = CONFIG.LANE_WIDTH/2 - 5;
                const safeY = CONFIG.LANE_HEIGHT/2 - 5;
                
                this.cx = (Math.random() - 0.5) * 2 * safeX;
                this.cy = (Math.random() - 0.5) * 2 * safeY;
                
                if (this.type === 'circle') {
                    this.radius = 3.5; // Slightly larger for gameplay feel
                    this.angle = 0;
                } else {
                    this.w = 3.5;  // Skinny
                    this.h = 10; // Long
                    this.angle = Math.random() * Math.PI; // Random angle
                }

                // Create Geometry via Shape
                const shape = new THREE.Shape();
                
                // Outer Wall (Huge rect)
                // Make it large enough so corners don't show blank space
                const outerW = CONFIG.LANE_WIDTH + 20; 
                const outerH = CONFIG.LANE_HEIGHT + 20;
                shape.moveTo(-outerW/2, -outerH/2);
                shape.lineTo(outerW/2, -outerH/2);
                shape.lineTo(outerW/2, outerH/2);
                shape.lineTo(-outerW/2, outerH/2);
                shape.lineTo(-outerW/2, -outerH/2);

                // Create Hole Path
                const holePath = new THREE.Path();
                if (this.type === 'circle') {
                    holePath.absarc(this.cx, this.cy, this.radius, 0, Math.PI * 2, false);
                } else {
                    // Rotated rect points
                    // Corners relative to center
                    const hw = this.w/2;
                    const hh = this.h/2;
                    
                    const cos = Math.cos(this.angle);
                    const sin = Math.sin(this.angle);

                    const corners = [
                        {x: -hw, y: -hh},
                        {x: hw, y: -hh},
                        {x: hw, y: hh},
                        {x: -hw, y: hh}
                    ];

                    // Transform and draw
                    corners.forEach((p, i) => {
                        // Rotate
                        const rx = p.x * cos - p.y * sin;
                        const ry = p.x * sin + p.y * cos;
                        // Translate
                        const fx = this.cx + rx;
                        const fy = this.cy + ry;
                        
                        if (i === 0) holePath.moveTo(fx, fy);
                        else holePath.lineTo(fx, fy);
                    });
                    // Close loop
                    // holePath.closePath(); // auto closed by shape?
                }
                shape.holes.push(holePath);

                // Extrude
                // Use less segments for performance, but enough for circle
                const geometry = new THREE.ExtrudeGeometry(shape, {
                    depth: 2,
                    bevelEnabled: false,
                    curveSegments: 24 
                });
                // Center Z
                geometry.translate(0, 0, -1);

                this.mesh = new THREE.Mesh(geometry, wallMaterial.clone());
                this.group.add(this.mesh);

                // Visual Guide (Neon Outline)
                this.createGuide(holePath);

                scene.add(this.group);
            }

            createGuide(path) {
                // Approximate path points
                const points = path.getPoints(); // Returns Vector2 array
                const points3d = points.map(p => new THREE.Vector3(p.x, p.y, 1.1));
                // Add first point again to close loop visually
                if(points3d.length > 0) points3d.push(points3d[0]);
                
                const geo = new THREE.BufferGeometry().setFromPoints(points3d);
                const mat = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                const line = new THREE.Line(geo, mat);
                this.group.add(line);
            }

            update(speed) {
                this.group.position.z += speed;
                
                // Check Collision if passing player
                // Player is at Z = CONFIG.PLAYER_Z
                // Wall thickness is 2, so roughly Z-1 to Z+1
                const dist = this.group.position.z - CONFIG.PLAYER_Z;

                if (!this.passed && !this.hit && dist > -1 && dist < 1) {
                    this.checkCollision();
                }

                if (this.group.position.z > CONFIG.DESPAWN_Z) {
                    this.remove();
                    return true; // Signal reset
                }
                return false;
            }

            checkCollision() {
                const hx = handCenter.x;
                const hy = handCenter.y;
                let isInside = false;

                if (this.type === 'circle') {
                    const distSq = (hx - this.cx)**2 + (hy - this.cy)**2;
                    // Strict radius check with slight tolerance for hand size
                    const handRadius = 0.5; 
                    if (distSq < (this.radius - handRadius)**2) {
                        isInside = true;
                    }
                } else {
                    // Rotated Rect
                    // 1. Translate point to rect local space (centered at origin)
                    const tx = hx - this.cx;
                    const ty = hy - this.cy;
                    
                    // 2. Rotate point by inverse angle (-angle) to align with AABB
                    const cos = Math.cos(-this.angle);
                    const sin = Math.sin(-this.angle);
                    
                    const rx = tx * cos - ty * sin;
                    const ry = tx * sin + ty * cos;
                    
                    // 3. AABB Check
                    const handTolerance = 0.5;
                    const halfW = this.w/2 - handTolerance;
                    const halfH = this.h/2 - handTolerance;
                    
                    if (Math.abs(rx) < halfW && Math.abs(ry) < halfH) {
                        isInside = true;
                    }
                }

                if (!isInside) {
                    this.hit = true;
                    this.mesh.material = hitMaterial;
                    handleCrash();
                } else {
                    this.passed = true;
                    handlePass();
                }
            }

            remove() {
                scene.remove(this.group);
                // Basic cleanup
                this.group.traverse(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                });
            }
        }

        // --- Game Logic Handling ---
        
        function handleCrash() {
            state.lives--;
            document.getElementById('lives-val').innerText = state.lives;
            camera.position.x = (Math.random()-0.5) * 2; // Shake
            setTimeout(() => camera.position.x = 0, 200);

            if (state.lives <= 0) {
                gameOver();
            }
        }

        function handlePass() {
            state.score += 100;
            document.getElementById('score-val').innerText = state.score;
            state.speed += CONFIG.SPEED_INC;
        }

        function spawnWall() {
            walls.push(new Wall(CONFIG.SPAWN_Z));
        }

        function gameOver() {
            state.isGameOver = true;
            document.getElementById('message-title').innerText = "GAME OVER";
            // Show score and Restart button
            let html = `Final Score: <span style="color:#00ffff">${state.score}</span><br><br>`;
            html += `<button onclick="restartGame()">Try Again</button>`;
            
            document.getElementById('message-sub').innerHTML = html;
            // Hide the button from the start menu if it exists (it was replaced by innerHTML above, but checking visibility)
            const btn = document.querySelector('#message-overlay button');
            if(btn) btn.style.display = 'inline-block'; 

            document.getElementById('message-overlay').style.display = 'block';
        }

        function startGame() {
            state.isMenu = false;
            state.isPaused = false; 
            // Wait for hand detection to actually unpause logic in onResults
            
            document.getElementById('message-overlay').style.display = 'none';
        }

        function restartGame() {
            state.score = 0;
            state.lives = 3;
            state.speed = CONFIG.INITIAL_SPEED;
            state.isGameOver = false;
            state.isPaused = false;
            state.isMenu = false;
            
            // Clear walls
            walls.forEach(w => w.remove());
            walls.length = 0;

            document.getElementById('score-val').innerText = 0;
            document.getElementById('lives-val').innerText = 3;
            document.getElementById('message-overlay').style.display = 'none';

            spawnWall();
        }

        // --- Hand Tracking & Loop ---
        const videoElement = document.getElementById('webcam-feed');
        const loadingScreen = document.getElementById('loading');
        
        // Setup MediaPipe
        function onResults(results) {
            loadingScreen.style.display = 'none';
            
            // If in menu, show overlay but update hands in background (cool effect)
            if (state.isMenu) {
                 document.getElementById('message-overlay').style.display = 'block';
                 if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                     handGroup.visible = true;
                     updateHandVisuals(results.multiHandLandmarks[0]);
                 }
                 return;
            }

            const hasHand = results.multiHandLandmarks && results.multiHandLandmarks.length > 0;
            
            if (state.isGameOver) {
                return;
            }

            if (!hasHand) {
                if (!state.isPaused && !state.isGameOver && !state.isMenu) {
                    state.isPaused = true;
                    document.getElementById('message-title').innerText = "PAUSED";
                    document.getElementById('message-sub').innerText = "Camera cannot see your hand";
                    // Only show text if paused, hide start button which might be there from init
                    const btn = document.querySelector('#message-overlay button');
                    if(btn) btn.style.display = 'none';
                    
                    document.getElementById('message-overlay').style.display = 'block';
                }
                handGroup.visible = false;
                return;
            }

            // Hand Found -> Resume
            if (state.isPaused && !state.isGameOver && !state.isMenu) {
                state.isPaused = false;
                document.getElementById('message-overlay').style.display = 'none';
            }
            
            handGroup.visible = true;
            updateHandVisuals(results.multiHandLandmarks[0]);
        }

        function updateHandVisuals(landmarks) {
            // Project Hand to fixed Z Player Plane
            const targetZ = CONFIG.PLAYER_Z;
            const vFOV = camera.fov * Math.PI / 180;
            
            // Calc projection dimensions at Z
            const dist = camera.position.z - targetZ; // 10 - 0 = 10
            const heightAtZ = 2 * Math.tan(vFOV / 2) * dist;
            const widthAtZ = heightAtZ * camera.aspect;

            const tempBox = new THREE.Box3();
            const dummy = new THREE.Object3D();

            landmarks.forEach((lm, i) => {
                const ndcX = (1 - lm.x) * 2 - 1; // Mirror
                const ndcY = -(lm.y * 2 - 1);
                
                // Scale to world dimensions
                const x = ndcX * widthAtZ / 2;
                const y = ndcY * heightAtZ / 2;
                // Add minor Z variation for volume
                const z = targetZ + (lm.z * -2); // Reduced Z scaling
                
                // Update Joints
                dummy.position.set(x, y, z);
                dummy.updateMatrix();
                jointMesh.setMatrixAt(i, dummy.matrix);

                // Expand bounds
                tempBox.expandByPoint(new THREE.Vector3(x,y,z));
                
                // Save positions for bones
                if (i <= 20) { 
                    // Store for wireframe... tricky with InstancedMesh, 
                    // actually we can just store in array for LineSegments
                     const v = new THREE.Vector3(x,y,z);
                     // We need to map bone indices. Done below efficiently.
                }
            });
            jointMesh.instanceMatrix.needsUpdate = true;
            
            // Update Wireframe
            const pos = handWire.geometry.attributes.position.array;
            let idx = 0;
            for (const [start, end] of HAND_CONNECTIONS) {
                // Retrieve matrices to get coords back is slow, let's recalculate or cache.
                // Fast recalc:
                const getPos = (i) => {
                    const lm = landmarks[i];
                    return new THREE.Vector3(
                        ((1 - lm.x) * 2 - 1) * widthAtZ / 2,
                        (-(lm.y * 2 - 1)) * heightAtZ / 2,
                        targetZ + (lm.z * -2)
                    );
                }
                const v1 = getPos(start);
                const v2 = getPos(end);
                 pos[idx++] = v1.x; pos[idx++] = v1.y; pos[idx++] = v1.z;
                 pos[idx++] = v2.x; pos[idx++] = v2.y; pos[idx++] = v2.z;
            }
            handWire.geometry.attributes.position.needsUpdate = true;

            // Update Logic Bounds
            handBounds.copy(tempBox);
            tempBox.getCenter(handCenter);
            playerBoxHelper.box.copy(handBounds); // Debug visual
        }


        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();

        // --- Render Loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            if (!state.isPaused && !state.isGameOver && !state.isMenu) {
                state.frame++;

                // Spawn Walls
                // Distance based spawn? Or time based.
                // Let's spawn every time the last wall moves X distance away from spawn
                if (walls.length === 0 || (CONFIG.SPAWN_Z - walls[walls.length-1].group.position.z) > 40) {
                    spawnWall();
                }

                // Move Walls
                for (let i = walls.length - 1; i >= 0; i--) {
                    const remove = walls[i].update(state.speed);
                    if (remove) walls.splice(i, 1);
                }
                
                // Animate Road (Grid)
                gridHelper.position.z += state.speed;
                if (gridHelper.position.z > -20) gridHelper.position.z = -40; // Loop
            }

            renderer.render(scene, camera);
        }
        
        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        state.isPaused = true; // Wait for hand
        animate();

    </script>
</body>
</html>